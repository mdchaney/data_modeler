<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Model Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        .controls {
            margin-bottom: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .controls button {
            margin-right: 10px;
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .controls button:hover {
            background: #0056b3;
        }
        #file-input {
            margin-right: 10px;
        }
        #diagram-container {
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            overflow: auto;
            position: relative;
            background: white;
        }
        svg {
            background: white;
        }
        .table-node {
            cursor: move;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.2));
        }
        .table-node:hover {
            filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.3));
        }
        .resize-handle {
            fill: transparent;
            stroke: none;
            cursor: pointer;
        }
        .resize-handle:hover {
            fill: rgba(0, 123, 255, 0.1);
        }
        .resize-n { cursor: n-resize; }
        .resize-e { cursor: e-resize; }
        .resize-s { cursor: s-resize; }
        .resize-w { cursor: w-resize; }
        .resize-ne { cursor: ne-resize; }
        .resize-se { cursor: se-resize; }
        .resize-sw { cursor: sw-resize; }
        .resize-nw { cursor: nw-resize; }
        .table-header {
            font-weight: bold;
            font-size: 14px;
        }
        .table-field {
            font-size: 12px;
        }
        .relationship-line {
            fill: none;
            stroke: #666;
            stroke-width: 2;
            marker-end: url(#arrowhead);
        }
        .relationship-group:hover .relationship-line {
            stroke: #333;
            stroke-width: 3;
        }
        .relationship-label {
            font-size: 11px;
            fill: #666;
        }
        #info-panel {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
            display: none;
        }
        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            z-index: 10;
        }
        .zoom-controls button {
            width: 30px;
            height: 30px;
            margin: 2px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 3px;
        }
        .zoom-controls button:hover {
            background: #f0f0f0;
        }
        .page-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
            color: #666;
        }
        .debug-info {
            margin-top: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            display: none;
        }
        #show-debug {
            font-size: 12px;
            padding: 4px 8px;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 600px;
            max-width: 90%;
            border-radius: 8px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover,
        .close:focus {
            color: black;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .field-list {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        .field-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            align-items: center;
        }
        .field-item input,
        .field-item select {
            flex: 1;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .field-item button {
            padding: 5px 10px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .field-item button:hover {
            background: #c82333;
        }
        .add-field-btn {
            width: 100%;
            padding: 10px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 15px;
        }
        .add-field-btn:hover {
            background: #218838;
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        .modal-buttons button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .modal-buttons .btn-primary {
            background: #007bff;
            color: white;
        }
        .modal-buttons .btn-primary:hover {
            background: #0056b3;
        }
        .modal-buttons .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .modal-buttons .btn-secondary:hover {
            background: #545b62;
        }
        
        /* Foreign Key Creation Mode */
        .fk-creation-mode {
            cursor: crosshair !important;
        }
        .fk-creation-mode * {
            cursor: crosshair !important;
        }
        .field-bg.field-hover {
            fill: rgba(0, 123, 255, 0.1);
        }
        .field-bg.field-selected {
            fill: rgba(0, 123, 255, 0.3);
        }
        .fk-drag-line {
            stroke: #007bff;
            stroke-width: 2;
            stroke-dasharray: 5,5;
            fill: none;
            pointer-events: none;
        }
        #fk-status {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #007bff;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            display: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Data Model Viewer</h1>
        
        <div class="controls">
            <input type="file" id="file-input" accept=".nmodel">
            <button onclick="loadFile()">Load Model</button>
            <button onclick="showAddTableDialog()">Add Table</button>
            <button onclick="startAddForeignKey()">Add Foreign Key</button>
            <button onclick="exportSVG()">Export as SVG</button>
            <button onclick="exportPNG()">Export as PNG</button>
            <button id="show-debug" onclick="toggleDebug()">Show Debug Info</button>
        </div>
        
        <div id="diagram-container">
            <div class="zoom-controls">
                <button onclick="zoom(1.2)">+</button>
                <button onclick="zoom(0.8)">-</button>
                <button onclick="resetZoom()">⟲</button>
            </div>
            <div class="page-info" id="page-info"></div>
            <svg id="diagram" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="10" 
                            refX="9" refY="3" orient="auto">
                        <polygon points="0 0, 10 3, 0 6" fill="#666" />
                    </marker>
                    <marker id="arrowhead-start" markerWidth="10" markerHeight="10" 
                            refX="1" refY="3" orient="auto">
                        <polygon points="10 0, 0 3, 10 6" fill="#666" />
                    </marker>
                    <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
                        <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#f0f0f0" stroke-width="1"/>
                    </pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid)" />
                <g id="zoom-group" transform="scale(1)">
                    <g id="relationships"></g>
                    <g id="tables"></g>
                </g>
            </svg>
        </div>
        
        <div id="debug-info" class="debug-info"></div>
        
        <div id="info-panel">
            <h3>Table Information</h3>
            <div id="info-content"></div>
        </div>
    </div>
    
    <!-- Add Table Modal -->
    <div id="addTableModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeAddTableDialog()">&times;</span>
            <h2>Add New Table</h2>
            
            <div class="form-group">
                <label for="tableName">Table Name:</label>
                <input type="text" id="tableName" placeholder="Enter table name (e.g., users)">
            </div>
            
            <div class="form-group">
                <label>Fields:</label>
                <div id="fieldsList" class="field-list">
                    <!-- Fields will be added here dynamically -->
                </div>
                <button class="add-field-btn" onclick="addFieldRow()">+ Add Field</button>
            </div>
            
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="closeAddTableDialog()">Cancel</button>
                <button class="btn-primary" onclick="createTable()">Create Table</button>
            </div>
        </div>
    </div>
    
    <!-- Foreign Key Modal -->
    <div id="addForeignKeyModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeForeignKeyDialog(); cancelForeignKeyCreation();">&times;</span>
            <h2>Create Foreign Key</h2>
            
            <div class="form-group">
                <label>From:</label>
                <p id="fk-from-info" style="margin: 5px 0; font-weight: bold;"></p>
            </div>
            
            <div class="form-group">
                <label>To:</label>
                <p id="fk-to-info" style="margin: 5px 0; font-weight: bold;"></p>
            </div>
            
            <div class="form-group">
                <label for="fkName">Foreign Key Name:</label>
                <input type="text" id="fkName" placeholder="fk_table1_table2">
            </div>
            
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="closeForeignKeyDialog(); cancelForeignKeyCreation();">Cancel</button>
                <button class="btn-primary" onclick="createForeignKey()">Create Foreign Key</button>
            </div>
        </div>
    </div>
    
    <!-- Foreign Key Status -->
    <div id="fk-status">Click on a field to start, then drag to another field</div>

    <script>
        let modelData = null;
        let currentZoom = 1;
        let draggedElement = null;
        let dragOffset = { x: 0, y: 0 };
        let resizingElement = null;
        let resizeHandle = null;
        let resizeStartPos = { x: 0, y: 0 };
        let resizeStartSize = { width: 0, height: 0 };
        let diagramInfo = {};
        let tablesMap = {}; // Map of table UUID to table schema
        let displayObjectsMap = {}; // Map of display UUID to display info
        let layoutInfo = {}; // Map of UUID to layout position info
        let relationshipsMap = {}; // Map of relationship UUID to relationship data
        let tableRelationships = {}; // Map of table UUID to connected relationship UUIDs
        
        // Foreign key creation mode variables
        let fkCreationMode = false;
        let fkSourceField = null;
        let fkTargetField = null;
        let fkDragLine = null;

        function loadFile() {
            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    modelData = JSON.parse(e.target.result);
                    parseAndRenderDiagram();
                } catch (error) {
                    alert('Error parsing file: ' + error.message);
                    console.error(error);
                }
            };
            reader.readAsText(file);
        }

        function parseAndRenderDiagram() {
            if (!modelData || !modelData.ObjectJsons) return;
            
            // Clear previous data
            tablesMap = {};
            displayObjectsMap = {};
            diagramInfo = {};
            layoutInfo = {};
            relationshipsMap = {};
            tableRelationships = {};
            
            // Find the MVDiagram object
            let mvDiagramUUID = null;
            let mvDiagramData = null;
            
            for (const [uuid, objects] of Object.entries(modelData.ObjectJsons)) {
                if (Array.isArray(objects)) {
                    const metaObj = objects.find(obj => obj._META_ && obj.ObjectTypeID === 'MVDiagram');
                    if (metaObj) {
                        mvDiagramUUID = uuid;
                        mvDiagramData = objects;
                        break;
                    }
                }
            }
            
            if (!mvDiagramUUID) {
                alert('No MVDiagram found in the file');
                return;
            }
            
            // Extract diagram info (pages, layout, etc.)
            for (const obj of mvDiagramData) {
                if (obj.PaperSize) {
                    diagramInfo.paperSize = obj.PaperSize;
                }
                if (obj.PagesSize) {
                    diagramInfo.pagesSize = obj.PagesSize;
                }
            }
            
            // Get list of child objects to display
            const childObjectUUIDs = mvDiagramData.find(obj => obj._META_)?.ChildObjectUUIDs || [];
            console.log('MVDiagram UUID:', mvDiagramUUID);
            console.log('Child UUIDs count:', childObjectUUIDs.length);
            
            // Parse all objects first to build our maps
            for (const [uuid, objects] of Object.entries(modelData.ObjectJsons)) {
                if (Array.isArray(objects)) {
                    const metaObj = objects.find(obj => obj._META_);
                    if (!metaObj) continue;
                    
                    // Check if it's a table schema
                    if (metaObj.ObjectTypeID === 'TableNormal_PGSQL') {
                        const tableData = objects.find(obj => obj.TableCommon);
                        if (tableData) {
                            tablesMap[uuid] = {
                                name: metaObj.ObjectName,
                                fields: tableData.TableCommon.Fields || [],
                                foreignKeys: tableData.TableCommon.ForeignKeys || []
                            };
                        }
                    }
                    
                    // Check if it's a display object for a table
                    if (metaObj.ObjectTypeID === 'MVDiagramModelObject_Table') {
                        const refObj = objects.find(obj => obj.RefUUID);
                        if (refObj) {
                            displayObjectsMap[uuid] = {
                                name: metaObj.ObjectName,
                                refUUID: refObj.RefUUID,
                                uuid: uuid
                            };
                            console.log(`Found display object: ${metaObj.ObjectName} (${uuid}) -> ${refObj.RefUUID}`);
                        }
                    }
                }
            }
            
            // Extract layout information from MVDiagram
            
            // Debug: Let's see what's actually in mvDiagramData
            console.log('mvDiagramData structure:', mvDiagramData);
            
            // The layout info should be in one of the objects
            // Let's check each object more carefully
            for (let i = 0; i < mvDiagramData.length; i++) {
                const obj = mvDiagramData[i];
                if (obj && typeof obj === 'object') {
                    console.log(`mvDiagramData[${i}] keys:`, Object.keys(obj));
                    
                    // Check if this object has a property that's an array
                    for (const [key, value] of Object.entries(obj)) {
                        if (Array.isArray(value) && value.length > 0) {
                            console.log(`  Found array property '${key}' with ${value.length} items`);
                            // Check first item to see if it has layout properties
                            if (value[0] && typeof value[0] === 'object') {
                                console.log(`    First item keys:`, Object.keys(value[0]));
                                if (value[0].RefUUID && value[0].Rect) {
                                    console.log(`    This looks like layout data!`);
                                    // Extract layout info
                                    value.forEach(item => {
                                        if (item.RefUUID && item.Rect) {
                                            layoutInfo[item.RefUUID] = {
                                                name: item.Name,
                                                rect: item.Rect
                                            };
                                        }
                                    });
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            console.log('Layout info extracted:', Object.keys(layoutInfo).length, 'items');
            
            // Set up the SVG dimensions
            setupSVGDimensions();
            
            // Render the diagram
            renderDiagram(childObjectUUIDs, layoutInfo);
            
            // Update debug info
            updateDebugInfo();
        }

        function setupSVGDimensions() {
            const svg = document.getElementById('diagram');
            
            if (diagramInfo.paperSize && diagramInfo.pagesSize) {
                const totalWidth = diagramInfo.paperSize.Width * diagramInfo.pagesSize.Width;
                const totalHeight = diagramInfo.paperSize.Height * diagramInfo.pagesSize.Height;
                
                svg.setAttribute('width', totalWidth);
                svg.setAttribute('height', totalHeight);
                svg.setAttribute('viewBox', `0 0 ${totalWidth} ${totalHeight}`);
                
                // Update page info
                const pageInfo = document.getElementById('page-info');
                pageInfo.textContent = `Canvas: ${totalWidth} × ${totalHeight} (${diagramInfo.pagesSize.Width} × ${diagramInfo.pagesSize.Height} pages)`;
            } else {
                // Default size
                svg.setAttribute('width', '2000');
                svg.setAttribute('height', '2000');
                svg.setAttribute('viewBox', '0 0 2000 2000');
            }
        }

        function renderDiagram(childObjectUUIDs, layoutInfo) {
            const tablesGroup = document.getElementById('tables');
            const relationshipsGroup = document.getElementById('relationships');
            
            // Clear existing content
            tablesGroup.innerHTML = '';
            relationshipsGroup.innerHTML = '';
            
            console.log('Child Object UUIDs:', childObjectUUIDs.length);
            console.log('Layout Info:', Object.keys(layoutInfo).length);
            console.log('Display Objects Map:', displayObjectsMap);
            
            let tablesRendered = 0;
            
            // First render tables
            childObjectUUIDs.forEach(uuid => {
                const displayObj = displayObjectsMap[uuid];
                console.log(`Checking UUID ${uuid}:`, displayObj);
                
                if (displayObj && !displayObj.name.startsWith('fk_')) {
                    // This is a table display object
                    const tableSchema = tablesMap[displayObj.refUUID];
                    const layout = layoutInfo[uuid];
                    
                    console.log(`  Table Schema:`, tableSchema?.name);
                    console.log(`  Layout:`, layout);
                    
                    if (tableSchema && layout) {
                        renderTable(uuid, tableSchema, layout.rect);
                        tablesRendered++;
                    }
                }
            });
            
            console.log(`Total tables rendered: ${tablesRendered}`);
            
            // Then render foreign key relationships
            childObjectUUIDs.forEach(uuid => {
                const layout = layoutInfo[uuid];
                if (layout && layout.name && layout.name.startsWith('fk_')) {
                    // This is a foreign key relationship
                    // Find the actual relationship data
                    const relationData = findRelationshipData(uuid);
                    if (relationData) {
                        // Store relationship data
                        relationshipsMap[uuid] = {
                            uuid: uuid,
                            name: layout.name,
                            data: relationData,
                            layout: layout
                        };
                        
                        // Track which tables this relationship connects
                        if (relationData.connectInfos) {
                            relationData.connectInfos.forEach(conn => {
                                if (!tableRelationships[conn.RefUUID]) {
                                    tableRelationships[conn.RefUUID] = [];
                                }
                                tableRelationships[conn.RefUUID].push(uuid);
                            });
                        }
                        
                        renderRelationship(uuid, layout.name, relationData);
                    }
                }
            });
        }

        function renderTable(uuid, table, position) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'table-node');
            g.setAttribute('data-uuid', uuid);
            g.setAttribute('transform', `translate(${position.X}, ${position.Y})`);
            
            // Table background
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', position.Width);
            rect.setAttribute('height', position.Height);
            rect.setAttribute('fill', '#ffffff');
            rect.setAttribute('stroke', '#3788d8');
            rect.setAttribute('stroke-width', '2');
            rect.setAttribute('rx', '4');
            g.appendChild(rect);
            
            // Table header
            const headerBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            headerBg.setAttribute('width', position.Width);
            headerBg.setAttribute('height', '30');
            headerBg.setAttribute('fill', '#3788d8');
            headerBg.setAttribute('rx', '4');
            g.appendChild(headerBg);
            
            // Fix header bottom corners
            const headerFix = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            headerFix.setAttribute('y', '20');
            headerFix.setAttribute('width', position.Width);
            headerFix.setAttribute('height', '10');
            headerFix.setAttribute('fill', '#3788d8');
            g.appendChild(headerFix);
            
            const headerText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            headerText.setAttribute('x', position.Width / 2);
            headerText.setAttribute('y', '20');
            headerText.setAttribute('text-anchor', 'middle');
            headerText.setAttribute('fill', 'white');
            headerText.setAttribute('class', 'table-header');
            headerText.textContent = table.name;
            g.appendChild(headerText);
            
            // Show first few fields
            let yPos = 45;
            // More accurate calculation: header takes ~35px, each field ~16px, leave 10px margin at bottom
            const availableHeight = position.Height - 35 - 10;
            const maxFieldsToShow = Math.floor(availableHeight / 16);
            const fieldsToShow = table.fields.slice(0, maxFieldsToShow);
            
            // Create a single clipPath for all fields
            const fieldsClipId = `fields-clip-${uuid}`;
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
            clipPath.setAttribute('id', fieldsClipId);
            const clipRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            clipRect.setAttribute('x', '8');
            clipRect.setAttribute('y', '0');
            clipRect.setAttribute('width', position.Width - 16);
            clipRect.setAttribute('height', position.Height);
            clipPath.appendChild(clipRect);
            defs.appendChild(clipPath);
            g.appendChild(defs);
            
            // Create a group for all fields with clipping
            const fieldsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            fieldsGroup.setAttribute('clip-path', `url(#${fieldsClipId})`);
            
            fieldsToShow.forEach((field, index) => {
                const fieldGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                fieldGroup.setAttribute('class', 'field-group');
                fieldGroup.setAttribute('data-field-name', field.Name);
                fieldGroup.setAttribute('data-field-type', field.Type);
                fieldGroup.setAttribute('data-table-uuid', uuid);
                fieldGroup.setAttribute('data-table-name', table.name);
                
                // Create invisible background rect for better click/hover detection
                const fieldBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                fieldBg.setAttribute('x', '8');
                fieldBg.setAttribute('y', yPos - 12);
                fieldBg.setAttribute('width', position.Width - 16);
                fieldBg.setAttribute('height', 16);
                fieldBg.setAttribute('fill', 'transparent');
                fieldBg.setAttribute('class', 'field-bg');
                fieldGroup.appendChild(fieldBg);
                
                const fieldText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                fieldText.setAttribute('x', '10');
                fieldText.setAttribute('y', yPos);
                fieldText.setAttribute('class', 'table-field');
                fieldText.setAttribute('pointer-events', 'none'); // Let the background handle events
                
                // For very long field names/types, we still need some truncation
                const fieldDisplay = `${field.Name}: ${field.Type}`;
                const maxChars = Math.floor((position.Width - 20) / 6);
                
                if (fieldDisplay.length > maxChars) {
                    fieldText.textContent = fieldDisplay.substring(0, maxChars - 3) + '...';
                } else {
                    fieldText.textContent = fieldDisplay;
                }
                
                fieldGroup.appendChild(fieldText);
                
                // Add foreign key creation event handlers
                fieldGroup.addEventListener('mouseenter', (e) => handleFieldHover(e, true));
                fieldGroup.addEventListener('mouseleave', (e) => handleFieldHover(e, false));
                fieldGroup.addEventListener('mousedown', (e) => handleFieldClick(e));
                
                fieldsGroup.appendChild(fieldGroup);
                yPos += 16;
            });
            
            g.appendChild(fieldsGroup);
            
            if (table.fields.length > maxFieldsToShow) {
                const moreText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                moreText.setAttribute('x', '10');
                moreText.setAttribute('y', yPos);
                moreText.setAttribute('class', 'table-field');
                moreText.setAttribute('fill', '#666');
                moreText.setAttribute('font-style', 'italic');
                const remaining = table.fields.length - maxFieldsToShow;
                moreText.textContent = `... ${remaining} more field${remaining !== 1 ? 's' : ''}`;
                g.appendChild(moreText);
            }
            
            // Add resize handles
            const handleSize = 8;
            const handles = [
                { class: 'resize-n', x: position.Width/2 - handleSize/2, y: -handleSize/2, width: handleSize, height: handleSize },
                { class: 'resize-ne', x: position.Width - handleSize/2, y: -handleSize/2, width: handleSize, height: handleSize },
                { class: 'resize-e', x: position.Width - handleSize/2, y: position.Height/2 - handleSize/2, width: handleSize, height: handleSize },
                { class: 'resize-se', x: position.Width - handleSize/2, y: position.Height - handleSize/2, width: handleSize, height: handleSize },
                { class: 'resize-s', x: position.Width/2 - handleSize/2, y: position.Height - handleSize/2, width: handleSize, height: handleSize },
                { class: 'resize-sw', x: -handleSize/2, y: position.Height - handleSize/2, width: handleSize, height: handleSize },
                { class: 'resize-w', x: -handleSize/2, y: position.Height/2 - handleSize/2, width: handleSize, height: handleSize },
                { class: 'resize-nw', x: -handleSize/2, y: -handleSize/2, width: handleSize, height: handleSize }
            ];
            
            handles.forEach(handle => {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('class', `resize-handle ${handle.class}`);
                rect.setAttribute('x', handle.x);
                rect.setAttribute('y', handle.y);
                rect.setAttribute('width', handle.width);
                rect.setAttribute('height', handle.height);
                rect.setAttribute('data-resize-type', handle.class.replace('resize-', ''));
                rect.addEventListener('mousedown', (e) => startResize(e, uuid));
                g.appendChild(rect);
            });
            
            // Add event handlers
            g.addEventListener('mousedown', (e) => {
                // Only start drag if not clicking on a resize handle
                if (!e.target.classList.contains('resize-handle')) {
                    startDrag(e);
                }
            });
            g.addEventListener('click', (e) => {
                // Only show info if not clicking on a resize handle
                if (!e.target.classList.contains('resize-handle')) {
                    showTableInfo(uuid, table);
                }
            });
            
            document.getElementById('tables').appendChild(g);
        }
        
        function findRelationshipData(uuid) {
            // Look for the relationship object in the model data
            const objects = modelData.ObjectJsons[uuid];
            if (!objects) return null;
            
            // Find the object with LineCommon (contains vertices)
            for (const obj of objects) {
                if (obj.LineCommon && obj.LineCommon.Vertices) {
                    return {
                        vertices: obj.LineCommon.Vertices,
                        connectInfos: obj.LineCommon.ConnectInfos || [],
                        relationCommon: obj.RelationCommon || {},
                        connectorCommon: obj.ConnectorCommon || {},
                        arrowCommon: obj.ArrowCommon || {}
                    };
                }
            }
            return null;
        }
        
        function generateElbowPath(vertices, offsetX, offsetY, startAxis) {
            if (vertices.length < 2) return '';
            
            // Convert control points to absolute positions
            const points = vertices.map(v => ({
                x: offsetX + v.X,
                y: offsetY + v.Y
            }));
            
            // Start with the first point
            let path = `M ${points[0].x} ${points[0].y}`;
            
            // For elbow connectors, we need to create horizontal/vertical segments
            // that pass through each control point
            let isHorizontal = startAxis === 'Horizontal';
            
            for (let i = 1; i < points.length; i++) {
                const prev = points[i - 1];
                const curr = points[i];
                
                if (isHorizontal) {
                    // Move horizontally to the x coordinate of the current point
                    path += ` L ${curr.x} ${prev.y}`;
                    // Then move vertically to reach the current point
                    if (prev.y !== curr.y) {
                        path += ` L ${curr.x} ${curr.y}`;
                    }
                } else {
                    // Move vertically to the y coordinate of the current point
                    path += ` L ${prev.x} ${curr.y}`;
                    // Then move horizontally to reach the current point
                    if (prev.x !== curr.x) {
                        path += ` L ${curr.x} ${curr.y}`;
                    }
                }
                
                // Toggle direction for next segment
                isHorizontal = !isHorizontal;
            }
            
            return path;
        }
        
        function renderRelationship(uuid, name, relData) {
            if (!relData.vertices || relData.vertices.length < 2) return;
            
            // Get the layout info for this relationship
            const layout = layoutInfo[uuid];
            if (!layout || !layout.rect) {
                console.warn(`No layout found for relationship ${name}`);
                return;
            }
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'relationship-group');
            g.setAttribute('data-uuid', uuid);
            g.setAttribute('data-name', name);
            
            // The vertices are relative to the relationship's bounding box
            const offsetX = layout.rect.X;
            const offsetY = layout.rect.Y;
            
            // Create the path based on connector type
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let d = '';
            
            if (relData.connectorCommon && relData.connectorCommon.Type === 'Elbow') {
                // Generate elbow connector path
                d = generateElbowPath(relData.vertices, offsetX, offsetY, 
                                    relData.connectorCommon.StartAxis || 'Horizontal');
            } else {
                // Default to straight lines through vertices
                d = `M ${offsetX + relData.vertices[0].X} ${offsetY + relData.vertices[0].Y}`;
                for (let i = 1; i < relData.vertices.length; i++) {
                    d += ` L ${offsetX + relData.vertices[i].X} ${offsetY + relData.vertices[i].Y}`;
                }
            }
            
            path.setAttribute('d', d);
            path.setAttribute('class', 'relationship-line');
            path.setAttribute('data-uuid', uuid);
            
            // Add arrow markers based on ArrowCommon
            if (relData.arrowCommon) {
                if (relData.arrowCommon.BeginStyle && relData.arrowCommon.BeginStyle !== 'None') {
                    path.setAttribute('marker-start', 'url(#arrowhead-start)');
                }
                if (relData.arrowCommon.EndStyle && relData.arrowCommon.EndStyle !== 'None') {
                    path.setAttribute('marker-end', 'url(#arrowhead)');
                }
            }
            
            // Make the line clickable with a wider invisible stroke
            const clickPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            clickPath.setAttribute('d', d);
            clickPath.setAttribute('stroke', 'transparent');
            clickPath.setAttribute('stroke-width', '10');
            clickPath.setAttribute('fill', 'none');
            clickPath.style.cursor = 'pointer';
            
            // Add click handler
            clickPath.addEventListener('click', () => showRelationshipInfo(uuid, name, relData));
            
            g.appendChild(clickPath);
            g.appendChild(path);
            
            // Debug: show bounding box
            if (window.debugMode) {
                const debugRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                debugRect.setAttribute('x', offsetX);
                debugRect.setAttribute('y', offsetY);
                debugRect.setAttribute('width', layout.rect.Width);
                debugRect.setAttribute('height', layout.rect.Height);
                debugRect.setAttribute('fill', 'none');
                debugRect.setAttribute('stroke', 'red');
                debugRect.setAttribute('stroke-width', '1');
                debugRect.setAttribute('stroke-dasharray', '5,5');
                g.appendChild(debugRect);
            }
            
            document.getElementById('relationships').appendChild(g);
        }
        
        function showRelationshipInfo(uuid, name, relData) {
            const infoPanel = document.getElementById('info-panel');
            const infoContent = document.getElementById('info-content');
            
            let html = `<h4>Relationship: ${name}</h4>`;
            html += `<p><strong>UUID:</strong> ${uuid}</p>`;
            
            if (relData.connectInfos && relData.connectInfos.length > 0) {
                html += '<p><strong>Connections:</strong></p>';
                html += '<ul>';
                relData.connectInfos.forEach((conn, idx) => {
                    const tableObj = displayObjectsMap[conn.RefUUID];
                    const tableName = tableObj ? tableObj.name : 'Unknown';
                    html += `<li>Connection ${idx + 1}: ${tableName} (UUID: ${conn.RefUUID}, Index: ${conn.Index})</li>`;
                });
                html += '</ul>';
            }
            
            if (relData.connectorCommon) {
                html += `<p><strong>Connector Type:</strong> ${relData.connectorCommon.Type || 'Unknown'}</p>`;
                html += `<p><strong>Start Axis:</strong> ${relData.connectorCommon.StartAxis || 'Unknown'}</p>`;
            }
            
            if (relData.arrowCommon) {
                html += `<p><strong>Arrow Style:</strong> Begin: ${relData.arrowCommon.BeginStyle || 'None'}, End: ${relData.arrowCommon.EndStyle || 'None'}</p>`;
            }
            
            infoContent.innerHTML = html;
            infoPanel.style.display = 'block';
        }

        function showTableInfo(uuid, table) {
            const infoPanel = document.getElementById('info-panel');
            const infoContent = document.getElementById('info-content');
            
            let html = `<h4>${table.name}</h4>`;
            html += `<p><strong>Total fields:</strong> ${table.fields.length}</p>`;
            
            if (table.fields && table.fields.length > 0) {
                html += '<table style="width: 100%; border-collapse: collapse; margin-top: 10px;">';
                html += '<tr>';
                html += '<th style="border: 1px solid #ddd; padding: 8px; background: #f8f9fa;">Field</th>';
                html += '<th style="border: 1px solid #ddd; padding: 8px; background: #f8f9fa;">Type</th>';
                html += '<th style="border: 1px solid #ddd; padding: 8px; background: #f8f9fa;">Nullable</th>';
                html += '<th style="border: 1px solid #ddd; padding: 8px; background: #f8f9fa;">Comment</th>';
                html += '</tr>';
                
                table.fields.forEach(field => {
                    html += `<tr>`;
                    html += `<td style="border: 1px solid #ddd; padding: 8px;">${field.Name}</td>`;
                    html += `<td style="border: 1px solid #ddd; padding: 8px;">${field.Type}${field.Length > 0 ? `(${field.Length})` : ''}</td>`;
                    html += `<td style="border: 1px solid #ddd; padding: 8px;">${field.IsNullable ? 'Yes' : 'No'}</td>`;
                    html += `<td style="border: 1px solid #ddd; padding: 8px;">${field.Comment || ''}</td>`;
                    html += `</tr>`;
                });
                
                html += '</table>';
            } else {
                html += '<p>No field information available for this table.</p>';
            }
            
            infoContent.innerHTML = html;
            infoPanel.style.display = 'block';
        }

        function updateDebugInfo() {
            const debugDiv = document.getElementById('debug-info');
            let html = '<strong>Debug Information:</strong><br>';
            html += `Total Objects: ${Object.keys(modelData.ObjectJsons).length}<br>`;
            html += `Tables Found: ${Object.keys(tablesMap).length}<br>`;
            html += `Display Objects: ${Object.keys(displayObjectsMap).length}<br>`;
            
            if (diagramInfo.paperSize && diagramInfo.pagesSize) {
                html += `<br><strong>Canvas Info:</strong><br>`;
                html += `Paper Size: ${diagramInfo.paperSize.Width} × ${diagramInfo.paperSize.Height}<br>`;
                html += `Pages: ${diagramInfo.pagesSize.Width} × ${diagramInfo.pagesSize.Height}<br>`;
                html += `Total Size: ${diagramInfo.paperSize.Width * diagramInfo.pagesSize.Width} × ${diagramInfo.paperSize.Height * diagramInfo.pagesSize.Height}<br>`;
            }
            
            debugDiv.innerHTML = html;
        }

        function toggleDebug() {
            const debugDiv = document.getElementById('debug-info');
            const button = document.getElementById('show-debug');
            if (debugDiv.style.display === 'none' || !debugDiv.style.display) {
                debugDiv.style.display = 'block';
                button.textContent = 'Hide Debug Info';
            } else {
                debugDiv.style.display = 'none';
                button.textContent = 'Show Debug Info';
            }
        }

        function zoom(factor) {
            currentZoom *= factor;
            currentZoom = Math.max(0.1, Math.min(5, currentZoom)); // Limit zoom range
            const zoomGroup = document.getElementById('zoom-group');
            zoomGroup.setAttribute('transform', `scale(${currentZoom})`);
        }

        function resetZoom() {
            currentZoom = 1;
            const zoomGroup = document.getElementById('zoom-group');
            zoomGroup.setAttribute('transform', 'scale(1)');
        }

        function startDrag(e) {
            if (e.target.tagName === 'text') return; // Don't drag when clicking text
            
            // Find the table group element
            let tableGroup = e.target;
            while (tableGroup && !tableGroup.classList.contains('table-node')) {
                tableGroup = tableGroup.parentElement;
            }
            if (!tableGroup) return;
            
            draggedElement = tableGroup;
            const transform = draggedElement.getAttribute('transform');
            const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
            if (!match) return;
            
            const x = parseFloat(match[1]);
            const y = parseFloat(match[2]);
            
            const svg = document.getElementById('diagram');
            const pt = svg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
            
            dragOffset.x = (svgP.x / currentZoom) - x;
            dragOffset.y = (svgP.y / currentZoom) - y;
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
            e.preventDefault();
            e.stopPropagation();
        }

        function drag(e) {
            if (!draggedElement) return;
            
            const svg = document.getElementById('diagram');
            const pt = svg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
            
            const x = (svgP.x / currentZoom) - dragOffset.x;
            const y = (svgP.y / currentZoom) - dragOffset.y;
            
            draggedElement.setAttribute('transform', `translate(${x}, ${y})`);
            
            // Update connected relationships
            const tableUUID = draggedElement.getAttribute('data-uuid');
            updateConnectedRelationships(tableUUID, x, y);
        }

        function updateConnectedRelationships(tableUUID, x, y) {
            // Get all relationships connected to this table
            const connectedRelationships = tableRelationships[tableUUID] || [];
            
            connectedRelationships.forEach(relUUID => {
                const relData = relationshipsMap[relUUID];
                if (!relData) return;
                
                // Find the relationship SVG element
                const relGroup = document.querySelector(`g[data-uuid="${relUUID}"]`);
                if (!relGroup) return;
                
                // Get the path elements
                const path = relGroup.querySelector('path.relationship-line');
                const clickPath = relGroup.querySelector('path[stroke="transparent"]');
                if (!path) return;
                
                // Recalculate the path based on current table positions
                const newPath = recalculateRelationshipPath(relUUID, relData);
                if (newPath) {
                    path.setAttribute('d', newPath);
                    if (clickPath) {
                        clickPath.setAttribute('d', newPath);
                    }
                }
            });
        }
        
        function recalculateRelationshipPath(relUUID, relData) {
            if (!relData.data.vertices || relData.data.vertices.length < 2) return null;
            
            // Get the connected tables' information
            const connectInfos = relData.data.connectInfos || [];
            if (connectInfos.length < 2) return null;
            
            const table1UUID = connectInfos[0].RefUUID;
            const table2UUID = connectInfos[1].RefUUID;
            
            const table1Element = document.querySelector(`g[data-uuid="${table1UUID}"]`);
            const table2Element = document.querySelector(`g[data-uuid="${table2UUID}"]`);
            
            if (!table1Element || !table2Element) return null;
            
            // Extract current positions from transform
            const getPosition = (element) => {
                const transform = element.getAttribute('transform');
                const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                if (!match) return { x: 0, y: 0 };
                return {
                    x: parseFloat(match[1]),
                    y: parseFloat(match[2])
                };
            };
            
            const pos1 = getPosition(table1Element);
            const pos2 = getPosition(table2Element);
            
            // Get table dimensions from the layout info
            const layout1 = layoutInfo[table1UUID];
            const layout2 = layoutInfo[table2UUID];
            
            if (!layout1 || !layout2) return null;
            
            // Calculate table centers
            const center1 = {
                x: pos1.x + layout1.rect.Width / 2,
                y: pos1.y + layout1.rect.Height / 2
            };
            const center2 = {
                x: pos2.x + layout2.rect.Width / 2,
                y: pos2.y + layout2.rect.Height / 2
            };
            
            // Determine the best sides to connect based on relative positions
            const dx = center2.x - center1.x;
            const dy = center2.y - center1.y;
            
            let index1, index2;
            
            // Choose connection sides based on which direction has the greater distance
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal relationship is dominant
                if (dx > 0) {
                    // Table 1 is to the left of Table 2
                    index1 = 2; // Right side of table 1
                    index2 = 0; // Left side of table 2
                } else {
                    // Table 1 is to the right of Table 2
                    index1 = 0; // Left side of table 1
                    index2 = 2; // Right side of table 2
                }
            } else {
                // Vertical relationship is dominant
                if (dy > 0) {
                    // Table 1 is above Table 2
                    index1 = 3; // Bottom of table 1
                    index2 = 1; // Top of table 2
                } else {
                    // Table 1 is below Table 2
                    index1 = 1; // Top of table 1
                    index2 = 3; // Bottom of table 2
                }
            }
            
            // Calculate connection points based on indices
            // Index meanings: 0=left, 1=top, 2=right, 3=bottom
            const getConnectionPoint = (pos, layout, index) => {
                const rect = layout.rect;
                const centerX = pos.x + rect.Width / 2;
                const centerY = pos.y + rect.Height / 2;
                
                switch(index) {
                    case 0: // Left
                        return { x: pos.x, y: centerY };
                    case 1: // Top
                        return { x: centerX, y: pos.y };
                    case 2: // Right
                        return { x: pos.x + rect.Width, y: centerY };
                    case 3: // Bottom
                        return { x: centerX, y: pos.y + rect.Height };
                    default: // Center as fallback
                        return { x: centerX, y: centerY };
                }
            };
            
            const point1 = getConnectionPoint(pos1, layout1, index1);
            const point2 = getConnectionPoint(pos2, layout2, index2);
            
            // For elbow connectors, create a simple path between the connection points
            let d = '';
            
            if (relData.data.connectorCommon && relData.data.connectorCommon.Type === 'Elbow') {
                // Create elbow path based on the connection sides
                d = `M ${point1.x} ${point1.y}`;
                
                // Determine path based on which sides are connected
                if ((index1 === 0 || index1 === 2) && (index2 === 0 || index2 === 2)) {
                    // Both connections are on left/right sides (horizontal)
                    const midX = (point1.x + point2.x) / 2;
                    d += ` L ${midX} ${point1.y}`;
                    d += ` L ${midX} ${point2.y}`;
                    d += ` L ${point2.x} ${point2.y}`;
                } else if ((index1 === 1 || index1 === 3) && (index2 === 1 || index2 === 3)) {
                    // Both connections are on top/bottom sides (vertical)
                    const midY = (point1.y + point2.y) / 2;
                    d += ` L ${point1.x} ${midY}`;
                    d += ` L ${point2.x} ${midY}`;
                    d += ` L ${point2.x} ${point2.y}`;
                } else if (index1 === 0 || index1 === 2) {
                    // First connection is horizontal, second is vertical
                    const extendDist = 30; // Distance to extend before turning
                    const extendX = index1 === 2 ? point1.x + extendDist : point1.x - extendDist;
                    d += ` L ${extendX} ${point1.y}`;
                    d += ` L ${extendX} ${point2.y}`;
                    d += ` L ${point2.x} ${point2.y}`;
                } else {
                    // First connection is vertical, second is horizontal
                    const extendDist = 30; // Distance to extend before turning
                    const extendY = index1 === 3 ? point1.y + extendDist : point1.y - extendDist;
                    d += ` L ${point1.x} ${extendY}`;
                    d += ` L ${point2.x} ${extendY}`;
                    d += ` L ${point2.x} ${point2.y}`;
                }
            } else {
                // Simple straight line
                d = `M ${point1.x} ${point1.y} L ${point2.x} ${point2.y}`;
            }
            
            return d;
        }

        function endDrag() {
            draggedElement = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', endDrag);
        }
        
        function startResize(e, uuid) {
            e.stopPropagation();
            e.preventDefault();
            
            resizingElement = e.currentTarget.parentElement;
            resizeHandle = e.currentTarget.getAttribute('data-resize-type');
            
            const svg = document.getElementById('diagram');
            const pt = svg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
            
            resizeStartPos.x = svgP.x / currentZoom;
            resizeStartPos.y = svgP.y / currentZoom;
            
            // Get current size and position from layout info
            const layout = layoutInfo[uuid];
            if (layout && layout.rect) {
                resizeStartSize.width = layout.rect.Width;
                resizeStartSize.height = layout.rect.Height;
                resizeStartSize.x = layout.rect.X;
                resizeStartSize.y = layout.rect.Y;
            }
            
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', endResize);
        }
        
        function resize(e) {
            if (!resizingElement || !resizeHandle) return;
            
            const svg = document.getElementById('diagram');
            const pt = svg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
            
            const currentX = svgP.x / currentZoom;
            const currentY = svgP.y / currentZoom;
            
            const dx = currentX - resizeStartPos.x;
            const dy = currentY - resizeStartPos.y;
            
            const uuid = resizingElement.getAttribute('data-uuid');
            const layout = layoutInfo[uuid];
            if (!layout || !layout.rect) return;
            
            let newWidth = resizeStartSize.width;
            let newHeight = resizeStartSize.height;
            let newX = resizeStartSize.x;
            let newY = resizeStartSize.y;
            
            // Calculate new dimensions based on resize handle
            switch(resizeHandle) {
                case 'n':
                    newY = resizeStartSize.y + dy;
                    newHeight = resizeStartSize.height - dy;
                    break;
                case 'ne':
                    newY = resizeStartSize.y + dy;
                    newHeight = resizeStartSize.height - dy;
                    newWidth = resizeStartSize.width + dx;
                    break;
                case 'e':
                    newWidth = resizeStartSize.width + dx;
                    break;
                case 'se':
                    newWidth = resizeStartSize.width + dx;
                    newHeight = resizeStartSize.height + dy;
                    break;
                case 's':
                    newHeight = resizeStartSize.height + dy;
                    break;
                case 'sw':
                    newX = resizeStartSize.x + dx;
                    newWidth = resizeStartSize.width - dx;
                    newHeight = resizeStartSize.height + dy;
                    break;
                case 'w':
                    newX = resizeStartSize.x + dx;
                    newWidth = resizeStartSize.width - dx;
                    break;
                case 'nw':
                    newX = resizeStartSize.x + dx;
                    newY = resizeStartSize.y + dy;
                    newWidth = resizeStartSize.width - dx;
                    newHeight = resizeStartSize.height - dy;
                    break;
            }
            
            // Minimum size constraints
            newWidth = Math.max(100, newWidth);
            newHeight = Math.max(60, newHeight);
            
            // Update layout info temporarily
            layout.rect.Width = newWidth;
            layout.rect.Height = newHeight;
            layout.rect.X = newX;
            layout.rect.Y = newY;
            
            // Update visual elements only (don't re-render completely)
            const backgroundRect = resizingElement.querySelector('rect');
            if (backgroundRect) {
                backgroundRect.setAttribute('width', newWidth);
                backgroundRect.setAttribute('height', newHeight);
            }
            
            // Update header background
            const headerRect = resizingElement.querySelector('rect[fill="#333"]');
            if (headerRect) {
                headerRect.setAttribute('width', newWidth);
            }
            
            // Update position if needed
            if (newX !== resizeStartSize.x || newY !== resizeStartSize.y) {
                resizingElement.setAttribute('transform', `translate(${newX}, ${newY})`);
            }
            
            // Update clip path
            const clipRect = resizingElement.querySelector('clipPath rect');
            if (clipRect) {
                clipRect.setAttribute('width', newWidth - 16);
                clipRect.setAttribute('height', newHeight);
            }
        }
        
        function endResize() {
            if (resizingElement) {
                const uuid = resizingElement.getAttribute('data-uuid');
                const layout = layoutInfo[uuid];
                const tableSchema = tablesMap[displayObjectsMap[uuid].refUUID];
                
                if (tableSchema && layout) {
                    // Remove the old element
                    resizingElement.remove();
                    
                    // Re-render with final dimensions
                    renderTable(uuid, tableSchema, layout.rect);
                    
                    // Update connected relationships
                    updateConnectedRelationships(uuid);
                }
            }
            
            resizingElement = null;
            resizeHandle = null;
            document.removeEventListener('mousemove', resize);
            document.removeEventListener('mouseup', endResize);
        }

        function exportSVG() {
            const svg = document.getElementById('diagram');
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            downloadFile(blob, 'diagram.svg');
        }

        function exportPNG() {
            const svg = document.getElementById('diagram');
            const svgData = new XMLSerializer().serializeToString(svg);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            img.onload = function() {
                canvas.width = svg.getAttribute('width');
                canvas.height = svg.getAttribute('height');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                canvas.toBlob(blob => {
                    downloadFile(blob, 'diagram.png');
                });
            };
            
            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
        }

        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Table creation functions
        function showAddTableDialog() {
            document.getElementById('addTableModal').style.display = 'block';
            document.getElementById('tableName').value = '';
            document.getElementById('fieldsList').innerHTML = '';
            // Add a default ID field
            addFieldRow('id', 'INTEGER', false, true);
        }
        
        function closeAddTableDialog() {
            document.getElementById('addTableModal').style.display = 'none';
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const tableModal = document.getElementById('addTableModal');
            const fkModal = document.getElementById('addForeignKeyModal');
            
            if (event.target === tableModal) {
                closeAddTableDialog();
            } else if (event.target === fkModal) {
                closeForeignKeyDialog();
            }
        }
        
        function addFieldRow(name = '', type = 'VARCHAR', nullable = true, isPrimary = false) {
            const fieldsList = document.getElementById('fieldsList');
            const fieldDiv = document.createElement('div');
            fieldDiv.className = 'field-item';
            
            fieldDiv.innerHTML = `
                <input type="text" placeholder="Field name" value="${name}" class="field-name">
                <select class="field-type">
                    <option value="INTEGER" ${type === 'INTEGER' ? 'selected' : ''}>INTEGER</option>
                    <option value="VARCHAR" ${type === 'VARCHAR' ? 'selected' : ''}>VARCHAR</option>
                    <option value="TEXT" ${type === 'TEXT' ? 'selected' : ''}>TEXT</option>
                    <option value="DECIMAL" ${type === 'DECIMAL' ? 'selected' : ''}>DECIMAL</option>
                    <option value="BOOLEAN" ${type === 'BOOLEAN' ? 'selected' : ''}>BOOLEAN</option>
                    <option value="DATE" ${type === 'DATE' ? 'selected' : ''}>DATE</option>
                    <option value="TIMESTAMP" ${type === 'TIMESTAMP' ? 'selected' : ''}>TIMESTAMP</option>
                    <option value="JSON" ${type === 'JSON' ? 'selected' : ''}>JSON</option>
                </select>
                <label style="display: flex; align-items: center; margin: 0;">
                    <input type="checkbox" ${!nullable ? 'checked' : ''} class="field-not-null" style="margin-right: 5px;">
                    NOT NULL
                </label>
                <label style="display: flex; align-items: center; margin: 0;">
                    <input type="checkbox" ${isPrimary ? 'checked' : ''} class="field-primary" style="margin-right: 5px;">
                    PRIMARY
                </label>
                <button onclick="this.parentElement.remove()">Remove</button>
            `;
            
            fieldsList.appendChild(fieldDiv);
        }
        
        function generateUUID() {
            // Generate a UUID v4
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16).toUpperCase();
            });
        }
        
        function createTable() {
            const tableName = document.getElementById('tableName').value.trim();
            if (!tableName) {
                alert('Please enter a table name');
                return;
            }
            
            // Collect fields
            const fieldItems = document.querySelectorAll('.field-item');
            const fields = [];
            
            fieldItems.forEach((item, index) => {
                const name = item.querySelector('.field-name').value.trim();
                const type = item.querySelector('.field-type').value;
                const notNull = item.querySelector('.field-not-null').checked;
                const isPrimary = item.querySelector('.field-primary').checked;
                
                if (name) {
                    fields.push({
                        uuid: generateUUID(),
                        name: name,
                        type: type,
                        nullable: !notNull,
                        isPrimary: isPrimary,
                        order: index
                    });
                }
            });
            
            if (fields.length === 0) {
                alert('Please add at least one field');
                return;
            }
            
            // Create the table
            const tableUUID = generateUUID();
            const displayUUID = generateUUID();
            
            // Add to model data structure
            if (!modelData) {
                // Initialize minimal model data structure if not loaded
                modelData = {
                    ObjectJsons: {},
                    MVDiagramData: {}
                };
            }
            
            // Create table schema object matching the expected format
            const tableSchema = {
                name: tableName,
                fields: fields.map(f => ({
                    Name: f.name,
                    Type: f.type,
                    IsNull: f.nullable ? "YES" : "NO",
                    IsPrimary: f.isPrimary,
                    OrderNum: f.order
                })),
                foreignKeys: []
            };
            
            // Add to tablesMap
            tablesMap[tableUUID] = tableSchema;
            
            // Find a good position for the new table
            let x = 50;
            let y = 50;
            
            // If there are existing tables, find the rightmost position
            if (Object.keys(layoutInfo).length > 0) {
                let maxX = 0;
                let maxY = 0;
                let rightmostY = 0;
                
                // Find the rightmost table
                for (const [uuid, layout] of Object.entries(layoutInfo)) {
                    if (layout.rect) {
                        const rightEdge = layout.rect.X + layout.rect.Width;
                        if (rightEdge > maxX) {
                            maxX = rightEdge;
                            rightmostY = layout.rect.Y;
                        }
                        maxY = Math.max(maxY, layout.rect.Y + layout.rect.Height);
                    }
                }
                
                // Place new table to the right of existing tables
                x = maxX + 50;
                y = rightmostY;
                
                // If it would be too far right, start a new row
                const svg = document.getElementById('diagram');
                const svgWidth = svg.clientWidth || 1200;
                if (x + 200 > svgWidth) {
                    x = 50;
                    y = maxY + 50;
                }
            }
            
            // Ensure the table is within the current viewport
            const container = document.getElementById('diagram-container');
            const scrollLeft = container.scrollLeft;
            const scrollTop = container.scrollTop;
            const viewWidth = container.clientWidth;
            const viewHeight = container.clientHeight;
            
            // Place it in the visible area if it would be outside
            if (x < scrollLeft || x > scrollLeft + viewWidth - 250) {
                x = scrollLeft + 50;
            }
            if (y < scrollTop || y > scrollTop + viewHeight - 200) {
                y = scrollTop + 50;
            }
            
            const displayObject = {
                uuid: displayUUID,
                name: tableName,
                refUUID: tableUUID  // This links the display object to the table schema
            };
            
            const layoutObject = {
                name: tableName,
                rect: {
                    X: x,
                    Y: y,
                    Width: 200,
                    Height: 100 + fields.length * 20
                }
            };
            
            // Add to display objects and layout info
            displayObjectsMap[displayUUID] = displayObject;
            layoutInfo[displayUUID] = layoutObject;
            
            // Render the new table
            renderTable(displayUUID, tableSchema, layoutObject.rect);
            
            // Close dialog
            closeAddTableDialog();
            
            // Scroll to the new table
            // Center the new table in the viewport
            const scrollX = Math.max(0, x - container.clientWidth / 2 + 100);
            const scrollY = Math.max(0, y - container.clientHeight / 2 + 75);
            container.scrollLeft = scrollX;
            container.scrollTop = scrollY;
            
            // Highlight the new table briefly
            const newTableElement = document.querySelector(`g[data-uuid="${displayUUID}"]`);
            if (newTableElement) {
                const rect = newTableElement.querySelector('rect');
                if (rect) {
                    const originalStroke = rect.getAttribute('stroke') || '#333';
                    const originalStrokeWidth = rect.getAttribute('stroke-width') || '1';
                    rect.setAttribute('stroke', '#007bff');
                    rect.setAttribute('stroke-width', '3');
                    
                    // Reset after 2 seconds
                    setTimeout(() => {
                        rect.setAttribute('stroke', originalStroke);
                        rect.setAttribute('stroke-width', originalStrokeWidth);
                    }, 2000);
                }
            }
        }
        
        // Foreign Key Creation Functions
        function startAddForeignKey() {
            fkCreationMode = true;
            fkSourceField = null;
            fkTargetField = null;
            
            // Show status message
            const status = document.getElementById('fk-status');
            status.style.display = 'block';
            status.textContent = 'Click on a source field to start';
            
            // Add creation mode class to body
            document.body.classList.add('fk-creation-mode');
            
            // Create drag line element
            if (!fkDragLine) {
                const svg = document.getElementById('diagram');
                const zoomGroup = document.getElementById('zoom-group');
                fkDragLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                fkDragLine.setAttribute('class', 'fk-drag-line');
                zoomGroup.appendChild(fkDragLine);
            }
            
            // Add escape key handler
            document.addEventListener('keydown', handleFKEscape);
        }
        
        function handleFKEscape(e) {
            if (e.key === 'Escape') {
                cancelForeignKeyCreation();
            }
        }
        
        function cancelForeignKeyCreation() {
            fkCreationMode = false;
            fkSourceField = null;
            fkTargetField = null;
            
            // Hide status
            document.getElementById('fk-status').style.display = 'none';
            
            // Remove creation mode class
            document.body.classList.remove('fk-creation-mode');
            
            // Remove drag line
            if (fkDragLine && fkDragLine.parentNode) {
                fkDragLine.parentNode.removeChild(fkDragLine);
                fkDragLine = null;
            }
            
            // Clear any highlighted fields
            document.querySelectorAll('.field-selected, .field-hover').forEach(el => {
                el.classList.remove('field-selected', 'field-hover');
            });
            
            // Remove escape handler
            document.removeEventListener('keydown', handleFKEscape);
            
            // Remove drag handlers
            document.removeEventListener('mousemove', handleFKDrag);
            document.removeEventListener('mouseup', handleFKDrop);
        }
        
        function handleFieldHover(e, isEntering) {
            if (!fkCreationMode) return;
            
            const fieldBg = e.currentTarget.querySelector('.field-bg');
            if (!fieldBg) return;
            
            if (isEntering) {
                fieldBg.classList.add('field-hover');
            } else {
                fieldBg.classList.remove('field-hover');
            }
        }
        
        function handleFieldClick(e) {
            if (!fkCreationMode) return;
            
            e.stopPropagation();
            e.preventDefault();
            
            const fieldGroup = e.currentTarget;
            const fieldBg = fieldGroup.querySelector('.field-bg');
            
            if (!fkSourceField) {
                // First click - select source field
                fkSourceField = {
                    tableUUID: fieldGroup.getAttribute('data-table-uuid'),
                    tableName: fieldGroup.getAttribute('data-table-name'),
                    fieldName: fieldGroup.getAttribute('data-field-name'),
                    fieldType: fieldGroup.getAttribute('data-field-type'),
                    element: fieldGroup
                };
                
                fieldBg.classList.add('field-selected');
                document.getElementById('fk-status').textContent = 'Now drag to the target field';
                
                // Start drag
                const rect = fieldGroup.getBoundingClientRect();
                const svg = document.getElementById('diagram');
                const pt = svg.createSVGPoint();
                pt.x = rect.left + rect.width / 2;
                pt.y = rect.top + rect.height / 2;
                const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                
                fkDragLine.setAttribute('x1', svgP.x / currentZoom);
                fkDragLine.setAttribute('y1', svgP.y / currentZoom);
                fkDragLine.setAttribute('x2', svgP.x / currentZoom);
                fkDragLine.setAttribute('y2', svgP.y / currentZoom);
                fkDragLine.style.display = 'block';
                
                document.addEventListener('mousemove', handleFKDrag);
                document.addEventListener('mouseup', handleFKDrop);
            }
        }
        
        function handleFKDrag(e) {
            if (!fkDragLine || !fkSourceField) return;
            
            const svg = document.getElementById('diagram');
            const pt = svg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
            
            fkDragLine.setAttribute('x2', svgP.x / currentZoom);
            fkDragLine.setAttribute('y2', svgP.y / currentZoom);
        }
        
        function handleFKDrop(e) {
            if (!fkSourceField) return;
            
            // Check if we're over a field
            const target = e.target;
            let fieldGroup = target;
            while (fieldGroup && !fieldGroup.classList.contains('field-group')) {
                fieldGroup = fieldGroup.parentElement;
            }
            
            if (fieldGroup && fieldGroup !== fkSourceField.element) {
                // Valid target field
                fkTargetField = {
                    tableUUID: fieldGroup.getAttribute('data-table-uuid'),
                    tableName: fieldGroup.getAttribute('data-table-name'),
                    fieldName: fieldGroup.getAttribute('data-field-name'),
                    fieldType: fieldGroup.getAttribute('data-field-type'),
                    element: fieldGroup
                };
                
                // Show foreign key dialog
                showForeignKeyDialog();
            } else {
                // Invalid drop - cancel
                cancelForeignKeyCreation();
            }
        }
        
        function showForeignKeyDialog() {
            if (!fkSourceField || !fkTargetField) return;
            
            // Store field data in the dialog for later retrieval
            const dialog = document.getElementById('addForeignKeyModal');
            dialog.dataset.sourceTableUuid = fkSourceField.tableUUID;
            dialog.dataset.sourceTableName = fkSourceField.tableName;
            dialog.dataset.sourceFieldName = fkSourceField.fieldName;
            dialog.dataset.sourceFieldType = fkSourceField.fieldType;
            dialog.dataset.targetTableUuid = fkTargetField.tableUUID;
            dialog.dataset.targetTableName = fkTargetField.tableName;
            dialog.dataset.targetFieldName = fkTargetField.fieldName;
            dialog.dataset.targetFieldType = fkTargetField.fieldType;
            
            // Hide drag line
            if (fkDragLine) {
                fkDragLine.style.display = 'none';
            }
            
            // Populate dialog
            document.getElementById('fk-from-info').textContent = 
                `${fkSourceField.tableName}.${fkSourceField.fieldName} (${fkSourceField.fieldType})`;
            document.getElementById('fk-to-info').textContent = 
                `${fkTargetField.tableName}.${fkTargetField.fieldName} (${fkTargetField.fieldType})`;
            
            // Generate default name
            document.getElementById('fkName').value = 
                `fk_${fkSourceField.tableName}_${fkTargetField.tableName}`;
            
            // Show dialog
            document.getElementById('addForeignKeyModal').style.display = 'block';
            
        }
        
        function closeForeignKeyDialog() {
            document.getElementById('addForeignKeyModal').style.display = 'none';
            // Don't call cancelForeignKeyCreation() here - we need to preserve the field data
        }
        
        function createForeignKey() {
            try {
                // If fields are null, try to retrieve from dialog dataset
                if (!fkSourceField || !fkTargetField) {
                    const dialog = document.getElementById('addForeignKeyModal');
                    
                    fkSourceField = {
                        tableUUID: dialog.dataset.sourceTableUuid,
                        tableName: dialog.dataset.sourceTableName,
                        fieldName: dialog.dataset.sourceFieldName,
                        fieldType: dialog.dataset.sourceFieldType
                    };
                    
                    fkTargetField = {
                        tableUUID: dialog.dataset.targetTableUuid,
                        tableName: dialog.dataset.targetTableName,
                        fieldName: dialog.dataset.targetFieldName,
                        fieldType: dialog.dataset.targetFieldType
                    };
                }
                
                if (!fkSourceField.tableUUID || !fkTargetField.tableUUID) {
                    alert('Please select both source and target fields');
                    return;
                }
                
                const fkName = document.getElementById('fkName').value.trim();
                if (!fkName) {
                    alert('Please enter a foreign key name');
                    return;
                }
                
                
                // Generate UUIDs
                const fkUUID = generateUUID();
                const displayUUID = generateUUID();
                
                // Get table positions to calculate initial vertices
                // The tableUUID from fields is the display UUID (since we set it in renderTable)
                const sourceLayout = layoutInfo[fkSourceField.tableUUID];
                const targetLayout = layoutInfo[fkTargetField.tableUUID];
                
                if (!sourceLayout || !targetLayout) {
                    alert('Cannot find table layouts');
                    console.error('Source layout:', sourceLayout, 'Target layout:', targetLayout);
                    return;
                }
            
                // Calculate a simple bounding box between the tables
                const sourceX = sourceLayout.rect.X;
                const sourceY = sourceLayout.rect.Y;
                const targetX = targetLayout.rect.X;
                const targetY = targetLayout.rect.Y;
                
                const minX = Math.min(sourceX, targetX) - 50;
                const minY = Math.min(sourceY, targetY) - 50;
                const maxX = Math.max(sourceX + sourceLayout.rect.Width, targetX + targetLayout.rect.Width) + 50;
                const maxY = Math.max(sourceY + sourceLayout.rect.Height, targetY + targetLayout.rect.Height) + 50;
                
                // Calculate vertices based on table positions
                // The vertices should be relative to the relationship's bounding box
                // For a simple connection, create vertices that go from source to target
                const relativeSourceX = sourceX - minX;
                const relativeSourceY = sourceY - minY;
                const relativeTargetX = targetX - minX;
                const relativeTargetY = targetY - minY;
                
                // Create vertices for an elbow connection
                const vertices = [
                    { X: relativeSourceX + sourceLayout.rect.Width, Y: relativeSourceY + sourceLayout.rect.Height / 2 },
                    { X: relativeSourceX + sourceLayout.rect.Width + 50, Y: relativeSourceY + sourceLayout.rect.Height / 2 },
                    { X: relativeSourceX + sourceLayout.rect.Width + 50, Y: relativeTargetY + targetLayout.rect.Height / 2 },
                    { X: relativeTargetX, Y: relativeTargetY + targetLayout.rect.Height / 2 }
                ];
                
                
                // Create the foreign key relationship data
                const relationshipData = {
                    uuid: fkUUID,
                    name: fkName,
                    vertices: vertices,
                    connectInfos: [
                        {
                            Index: 2, // Right side
                            RefUUID: fkSourceField.tableUUID
                        },
                        {
                            Index: 0, // Left side
                            RefUUID: fkTargetField.tableUUID
                        }
                    ],
                    connectorCommon: {
                        Type: "Elbow",
                        StartAxis: "Horizontal"
                    },
                    arrowCommon: {
                        BeginStyle: "None",
                        EndStyle: "None"
                    }
                };
                
                
                // Add to relationships map
                relationshipsMap[fkUUID] = {
                    data: relationshipData,
                    layout: {
                        rect: {
                            X: 0,
                            Y: 0,
                            Width: 200,
                            Height: 200
                        }
                    }
                };
                
                // Update table relationships
                [fkSourceField.tableUUID, fkTargetField.tableUUID].forEach(tableUUID => {
                    if (!tableRelationships[tableUUID]) {
                        tableRelationships[tableUUID] = [];
                    }
                    tableRelationships[tableUUID].push(fkUUID);
                });
                
                // Add to layout info with proper bounding box
                layoutInfo[displayUUID] = {
                    name: fkName,
                    rect: {
                        X: minX,
                        Y: minY,
                        Width: Math.max(100, maxX - minX),
                        Height: Math.max(100, maxY - minY)
                    }
                };
                
                
                // Add to display objects
                displayObjectsMap[displayUUID] = {
                    name: fkName,
                    refUUID: fkUUID
                };
                
                // Render the relationship
                renderRelationship(displayUUID, fkName, relationshipData);
                
                // Close dialog and cleanup
                closeForeignKeyDialog();
                cancelForeignKeyCreation();  // Now we can clear the fields
                
            } catch (error) {
                console.error('Error creating foreign key:', error);
                alert('Error creating foreign key: ' + error.message);
            }
        }
    </script>
</body>
</html>