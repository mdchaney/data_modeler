<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Navicat Data Model Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        .controls {
            margin-bottom: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .controls button {
            margin-right: 10px;
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .controls button:hover {
            background: #0056b3;
        }
        #file-input {
            margin-right: 10px;
        }
        #diagram-container {
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            overflow: auto;
            position: relative;
            background: white;
        }
        svg {
            background: white;
        }
        .table-node {
            cursor: move;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.2));
        }
        .table-node:hover {
            filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.3));
        }
        .table-header {
            font-weight: bold;
            font-size: 14px;
        }
        .table-field {
            font-size: 12px;
        }
        .relationship-line {
            fill: none;
            stroke: #666;
            stroke-width: 2;
            marker-end: url(#arrowhead);
        }
        .relationship-group:hover .relationship-line {
            stroke: #333;
            stroke-width: 3;
        }
        .relationship-label {
            font-size: 11px;
            fill: #666;
        }
        #info-panel {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
            display: none;
        }
        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            z-index: 10;
        }
        .zoom-controls button {
            width: 30px;
            height: 30px;
            margin: 2px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 3px;
        }
        .zoom-controls button:hover {
            background: #f0f0f0;
        }
        .page-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
            color: #666;
        }
        .debug-info {
            margin-top: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            display: none;
        }
        #show-debug {
            font-size: 12px;
            padding: 4px 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Navicat Data Model Viewer</h1>
        
        <div class="controls">
            <input type="file" id="file-input" accept=".nmodel">
            <button onclick="loadFile()">Load Model</button>
            <button onclick="exportSVG()">Export as SVG</button>
            <button onclick="exportPNG()">Export as PNG</button>
            <button id="show-debug" onclick="toggleDebug()">Show Debug Info</button>
        </div>
        
        <div id="diagram-container">
            <div class="zoom-controls">
                <button onclick="zoom(1.2)">+</button>
                <button onclick="zoom(0.8)">-</button>
                <button onclick="resetZoom()">⟲</button>
            </div>
            <div class="page-info" id="page-info"></div>
            <svg id="diagram" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="10" 
                            refX="9" refY="3" orient="auto">
                        <polygon points="0 0, 10 3, 0 6" fill="#666" />
                    </marker>
                    <marker id="arrowhead-start" markerWidth="10" markerHeight="10" 
                            refX="1" refY="3" orient="auto">
                        <polygon points="10 0, 0 3, 10 6" fill="#666" />
                    </marker>
                    <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
                        <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#f0f0f0" stroke-width="1"/>
                    </pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid)" />
                <g id="zoom-group" transform="scale(1)">
                    <g id="relationships"></g>
                    <g id="tables"></g>
                </g>
            </svg>
        </div>
        
        <div id="debug-info" class="debug-info"></div>
        
        <div id="info-panel">
            <h3>Table Information</h3>
            <div id="info-content"></div>
        </div>
    </div>

    <script>
        let modelData = null;
        let currentZoom = 1;
        let draggedElement = null;
        let dragOffset = { x: 0, y: 0 };
        let diagramInfo = {};
        let tablesMap = {}; // Map of table UUID to table schema
        let displayObjectsMap = {}; // Map of display UUID to display info
        let layoutInfo = {}; // Map of UUID to layout position info
        let relationshipsMap = {}; // Map of relationship UUID to relationship data
        let tableRelationships = {}; // Map of table UUID to connected relationship UUIDs

        function loadFile() {
            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    modelData = JSON.parse(e.target.result);
                    parseAndRenderDiagram();
                } catch (error) {
                    alert('Error parsing file: ' + error.message);
                    console.error(error);
                }
            };
            reader.readAsText(file);
        }

        function parseAndRenderDiagram() {
            if (!modelData || !modelData.ObjectJsons) return;
            
            // Clear previous data
            tablesMap = {};
            displayObjectsMap = {};
            diagramInfo = {};
            layoutInfo = {};
            relationshipsMap = {};
            tableRelationships = {};
            
            // Find the MVDiagram object
            let mvDiagramUUID = null;
            let mvDiagramData = null;
            
            for (const [uuid, objects] of Object.entries(modelData.ObjectJsons)) {
                if (Array.isArray(objects)) {
                    const metaObj = objects.find(obj => obj._META_ && obj.ObjectTypeID === 'MVDiagram');
                    if (metaObj) {
                        mvDiagramUUID = uuid;
                        mvDiagramData = objects;
                        break;
                    }
                }
            }
            
            if (!mvDiagramUUID) {
                alert('No MVDiagram found in the file');
                return;
            }
            
            // Extract diagram info (pages, layout, etc.)
            for (const obj of mvDiagramData) {
                if (obj.PaperSize) {
                    diagramInfo.paperSize = obj.PaperSize;
                }
                if (obj.PagesSize) {
                    diagramInfo.pagesSize = obj.PagesSize;
                }
            }
            
            // Get list of child objects to display
            const childObjectUUIDs = mvDiagramData.find(obj => obj._META_)?.ChildObjectUUIDs || [];
            console.log('MVDiagram UUID:', mvDiagramUUID);
            console.log('Child UUIDs count:', childObjectUUIDs.length);
            
            // Parse all objects first to build our maps
            for (const [uuid, objects] of Object.entries(modelData.ObjectJsons)) {
                if (Array.isArray(objects)) {
                    const metaObj = objects.find(obj => obj._META_);
                    if (!metaObj) continue;
                    
                    // Check if it's a table schema
                    if (metaObj.ObjectTypeID === 'TableNormal_PGSQL') {
                        const tableData = objects.find(obj => obj.TableCommon);
                        if (tableData) {
                            tablesMap[uuid] = {
                                name: metaObj.ObjectName,
                                fields: tableData.TableCommon.Fields || [],
                                foreignKeys: tableData.TableCommon.ForeignKeys || []
                            };
                        }
                    }
                    
                    // Check if it's a display object for a table
                    if (metaObj.ObjectTypeID === 'MVDiagramModelObject_Table') {
                        const refObj = objects.find(obj => obj.RefUUID);
                        if (refObj) {
                            displayObjectsMap[uuid] = {
                                name: metaObj.ObjectName,
                                refUUID: refObj.RefUUID,
                                uuid: uuid
                            };
                            console.log(`Found display object: ${metaObj.ObjectName} (${uuid}) -> ${refObj.RefUUID}`);
                        }
                    }
                }
            }
            
            // Extract layout information from MVDiagram
            
            // Debug: Let's see what's actually in mvDiagramData
            console.log('mvDiagramData structure:', mvDiagramData);
            
            // The layout info should be in one of the objects
            // Let's check each object more carefully
            for (let i = 0; i < mvDiagramData.length; i++) {
                const obj = mvDiagramData[i];
                if (obj && typeof obj === 'object') {
                    console.log(`mvDiagramData[${i}] keys:`, Object.keys(obj));
                    
                    // Check if this object has a property that's an array
                    for (const [key, value] of Object.entries(obj)) {
                        if (Array.isArray(value) && value.length > 0) {
                            console.log(`  Found array property '${key}' with ${value.length} items`);
                            // Check first item to see if it has layout properties
                            if (value[0] && typeof value[0] === 'object') {
                                console.log(`    First item keys:`, Object.keys(value[0]));
                                if (value[0].RefUUID && value[0].Rect) {
                                    console.log(`    This looks like layout data!`);
                                    // Extract layout info
                                    value.forEach(item => {
                                        if (item.RefUUID && item.Rect) {
                                            layoutInfo[item.RefUUID] = {
                                                name: item.Name,
                                                rect: item.Rect
                                            };
                                        }
                                    });
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            console.log('Layout info extracted:', Object.keys(layoutInfo).length, 'items');
            
            // Set up the SVG dimensions
            setupSVGDimensions();
            
            // Render the diagram
            renderDiagram(childObjectUUIDs, layoutInfo);
            
            // Update debug info
            updateDebugInfo();
        }

        function setupSVGDimensions() {
            const svg = document.getElementById('diagram');
            
            if (diagramInfo.paperSize && diagramInfo.pagesSize) {
                const totalWidth = diagramInfo.paperSize.Width * diagramInfo.pagesSize.Width;
                const totalHeight = diagramInfo.paperSize.Height * diagramInfo.pagesSize.Height;
                
                svg.setAttribute('width', totalWidth);
                svg.setAttribute('height', totalHeight);
                svg.setAttribute('viewBox', `0 0 ${totalWidth} ${totalHeight}`);
                
                // Update page info
                const pageInfo = document.getElementById('page-info');
                pageInfo.textContent = `Canvas: ${totalWidth} × ${totalHeight} (${diagramInfo.pagesSize.Width} × ${diagramInfo.pagesSize.Height} pages)`;
            } else {
                // Default size
                svg.setAttribute('width', '2000');
                svg.setAttribute('height', '2000');
                svg.setAttribute('viewBox', '0 0 2000 2000');
            }
        }

        function renderDiagram(childObjectUUIDs, layoutInfo) {
            const tablesGroup = document.getElementById('tables');
            const relationshipsGroup = document.getElementById('relationships');
            
            // Clear existing content
            tablesGroup.innerHTML = '';
            relationshipsGroup.innerHTML = '';
            
            console.log('Child Object UUIDs:', childObjectUUIDs.length);
            console.log('Layout Info:', Object.keys(layoutInfo).length);
            console.log('Display Objects Map:', displayObjectsMap);
            
            let tablesRendered = 0;
            
            // First render tables
            childObjectUUIDs.forEach(uuid => {
                const displayObj = displayObjectsMap[uuid];
                console.log(`Checking UUID ${uuid}:`, displayObj);
                
                if (displayObj && !displayObj.name.startsWith('fk_')) {
                    // This is a table display object
                    const tableSchema = tablesMap[displayObj.refUUID];
                    const layout = layoutInfo[uuid];
                    
                    console.log(`  Table Schema:`, tableSchema?.name);
                    console.log(`  Layout:`, layout);
                    
                    if (tableSchema && layout) {
                        renderTable(uuid, tableSchema, layout.rect);
                        tablesRendered++;
                    }
                }
            });
            
            console.log(`Total tables rendered: ${tablesRendered}`);
            
            // Then render foreign key relationships
            childObjectUUIDs.forEach(uuid => {
                const layout = layoutInfo[uuid];
                if (layout && layout.name && layout.name.startsWith('fk_')) {
                    // This is a foreign key relationship
                    // Find the actual relationship data
                    const relationData = findRelationshipData(uuid);
                    if (relationData) {
                        // Store relationship data
                        relationshipsMap[uuid] = {
                            uuid: uuid,
                            name: layout.name,
                            data: relationData,
                            layout: layout
                        };
                        
                        // Track which tables this relationship connects
                        if (relationData.connectInfos) {
                            relationData.connectInfos.forEach(conn => {
                                if (!tableRelationships[conn.RefUUID]) {
                                    tableRelationships[conn.RefUUID] = [];
                                }
                                tableRelationships[conn.RefUUID].push(uuid);
                            });
                        }
                        
                        renderRelationship(uuid, layout.name, relationData);
                    }
                }
            });
        }

        function renderTable(uuid, table, position) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'table-node');
            g.setAttribute('data-uuid', uuid);
            g.setAttribute('transform', `translate(${position.X}, ${position.Y})`);
            
            // Table background
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', position.Width);
            rect.setAttribute('height', position.Height);
            rect.setAttribute('fill', '#ffffff');
            rect.setAttribute('stroke', '#3788d8');
            rect.setAttribute('stroke-width', '2');
            rect.setAttribute('rx', '4');
            g.appendChild(rect);
            
            // Table header
            const headerBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            headerBg.setAttribute('width', position.Width);
            headerBg.setAttribute('height', '30');
            headerBg.setAttribute('fill', '#3788d8');
            headerBg.setAttribute('rx', '4');
            g.appendChild(headerBg);
            
            // Fix header bottom corners
            const headerFix = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            headerFix.setAttribute('y', '20');
            headerFix.setAttribute('width', position.Width);
            headerFix.setAttribute('height', '10');
            headerFix.setAttribute('fill', '#3788d8');
            g.appendChild(headerFix);
            
            const headerText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            headerText.setAttribute('x', position.Width / 2);
            headerText.setAttribute('y', '20');
            headerText.setAttribute('text-anchor', 'middle');
            headerText.setAttribute('fill', 'white');
            headerText.setAttribute('class', 'table-header');
            headerText.textContent = table.name;
            g.appendChild(headerText);
            
            // Show first few fields
            let yPos = 45;
            const maxFieldsToShow = Math.floor((position.Height - 50) / 18);
            const fieldsToShow = table.fields.slice(0, maxFieldsToShow);
            
            fieldsToShow.forEach((field, index) => {
                const fieldText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                fieldText.setAttribute('x', '10');
                fieldText.setAttribute('y', yPos);
                fieldText.setAttribute('class', 'table-field');
                
                // Truncate field display if needed
                const fieldDisplay = `${field.Name}: ${field.Type}`;
                const maxLength = Math.floor((position.Width - 20) / 7);
                fieldText.textContent = fieldDisplay.length > maxLength 
                    ? fieldDisplay.substring(0, maxLength - 3) + '...' 
                    : fieldDisplay;
                
                g.appendChild(fieldText);
                yPos += 18;
            });
            
            if (table.fields.length > maxFieldsToShow) {
                const moreText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                moreText.setAttribute('x', '10');
                moreText.setAttribute('y', yPos);
                moreText.setAttribute('class', 'table-field');
                moreText.setAttribute('fill', '#666');
                moreText.setAttribute('font-style', 'italic');
                moreText.textContent = `... ${table.fields.length - maxFieldsToShow} more fields`;
                g.appendChild(moreText);
            }
            
            // Add event handlers
            g.addEventListener('mousedown', startDrag);
            g.addEventListener('click', () => showTableInfo(uuid, table));
            
            document.getElementById('tables').appendChild(g);
        }
        
        function findRelationshipData(uuid) {
            // Look for the relationship object in the model data
            const objects = modelData.ObjectJsons[uuid];
            if (!objects) return null;
            
            // Find the object with LineCommon (contains vertices)
            for (const obj of objects) {
                if (obj.LineCommon && obj.LineCommon.Vertices) {
                    return {
                        vertices: obj.LineCommon.Vertices,
                        connectInfos: obj.LineCommon.ConnectInfos || [],
                        relationCommon: obj.RelationCommon || {},
                        connectorCommon: obj.ConnectorCommon || {},
                        arrowCommon: obj.ArrowCommon || {}
                    };
                }
            }
            return null;
        }
        
        function generateElbowPath(vertices, offsetX, offsetY, startAxis) {
            if (vertices.length < 2) return '';
            
            // Convert control points to absolute positions
            const points = vertices.map(v => ({
                x: offsetX + v.X,
                y: offsetY + v.Y
            }));
            
            // Start with the first point
            let path = `M ${points[0].x} ${points[0].y}`;
            
            // For elbow connectors, we need to create horizontal/vertical segments
            // that pass through each control point
            let isHorizontal = startAxis === 'Horizontal';
            
            for (let i = 1; i < points.length; i++) {
                const prev = points[i - 1];
                const curr = points[i];
                
                if (isHorizontal) {
                    // Move horizontally to the x coordinate of the current point
                    path += ` L ${curr.x} ${prev.y}`;
                    // Then move vertically to reach the current point
                    if (prev.y !== curr.y) {
                        path += ` L ${curr.x} ${curr.y}`;
                    }
                } else {
                    // Move vertically to the y coordinate of the current point
                    path += ` L ${prev.x} ${curr.y}`;
                    // Then move horizontally to reach the current point
                    if (prev.x !== curr.x) {
                        path += ` L ${curr.x} ${curr.y}`;
                    }
                }
                
                // Toggle direction for next segment
                isHorizontal = !isHorizontal;
            }
            
            return path;
        }
        
        function renderRelationship(uuid, name, relData) {
            if (!relData.vertices || relData.vertices.length < 2) return;
            
            // Get the layout info for this relationship
            const layout = layoutInfo[uuid];
            if (!layout || !layout.rect) {
                console.warn(`No layout found for relationship ${name}`);
                return;
            }
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'relationship-group');
            g.setAttribute('data-uuid', uuid);
            g.setAttribute('data-name', name);
            
            // The vertices are relative to the relationship's bounding box
            const offsetX = layout.rect.X;
            const offsetY = layout.rect.Y;
            
            // Create the path based on connector type
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let d = '';
            
            if (relData.connectorCommon && relData.connectorCommon.Type === 'Elbow') {
                // Generate elbow connector path
                d = generateElbowPath(relData.vertices, offsetX, offsetY, 
                                    relData.connectorCommon.StartAxis || 'Horizontal');
            } else {
                // Default to straight lines through vertices
                d = `M ${offsetX + relData.vertices[0].X} ${offsetY + relData.vertices[0].Y}`;
                for (let i = 1; i < relData.vertices.length; i++) {
                    d += ` L ${offsetX + relData.vertices[i].X} ${offsetY + relData.vertices[i].Y}`;
                }
            }
            
            path.setAttribute('d', d);
            path.setAttribute('class', 'relationship-line');
            path.setAttribute('data-uuid', uuid);
            
            // Add arrow markers based on ArrowCommon
            if (relData.arrowCommon) {
                if (relData.arrowCommon.BeginStyle && relData.arrowCommon.BeginStyle !== 'None') {
                    path.setAttribute('marker-start', 'url(#arrowhead-start)');
                }
                if (relData.arrowCommon.EndStyle && relData.arrowCommon.EndStyle !== 'None') {
                    path.setAttribute('marker-end', 'url(#arrowhead)');
                }
            }
            
            // Make the line clickable with a wider invisible stroke
            const clickPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            clickPath.setAttribute('d', d);
            clickPath.setAttribute('stroke', 'transparent');
            clickPath.setAttribute('stroke-width', '10');
            clickPath.setAttribute('fill', 'none');
            clickPath.style.cursor = 'pointer';
            
            // Add click handler
            clickPath.addEventListener('click', () => showRelationshipInfo(uuid, name, relData));
            
            g.appendChild(clickPath);
            g.appendChild(path);
            
            // Debug: show bounding box
            if (window.debugMode) {
                const debugRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                debugRect.setAttribute('x', offsetX);
                debugRect.setAttribute('y', offsetY);
                debugRect.setAttribute('width', layout.rect.Width);
                debugRect.setAttribute('height', layout.rect.Height);
                debugRect.setAttribute('fill', 'none');
                debugRect.setAttribute('stroke', 'red');
                debugRect.setAttribute('stroke-width', '1');
                debugRect.setAttribute('stroke-dasharray', '5,5');
                g.appendChild(debugRect);
            }
            
            document.getElementById('relationships').appendChild(g);
        }
        
        function showRelationshipInfo(uuid, name, relData) {
            const infoPanel = document.getElementById('info-panel');
            const infoContent = document.getElementById('info-content');
            
            let html = `<h4>Relationship: ${name}</h4>`;
            html += `<p><strong>UUID:</strong> ${uuid}</p>`;
            
            if (relData.connectInfos && relData.connectInfos.length > 0) {
                html += '<p><strong>Connections:</strong></p>';
                html += '<ul>';
                relData.connectInfos.forEach((conn, idx) => {
                    const tableObj = displayObjectsMap[conn.RefUUID];
                    const tableName = tableObj ? tableObj.name : 'Unknown';
                    html += `<li>Connection ${idx + 1}: ${tableName} (UUID: ${conn.RefUUID}, Index: ${conn.Index})</li>`;
                });
                html += '</ul>';
            }
            
            if (relData.connectorCommon) {
                html += `<p><strong>Connector Type:</strong> ${relData.connectorCommon.Type || 'Unknown'}</p>`;
                html += `<p><strong>Start Axis:</strong> ${relData.connectorCommon.StartAxis || 'Unknown'}</p>`;
            }
            
            if (relData.arrowCommon) {
                html += `<p><strong>Arrow Style:</strong> Begin: ${relData.arrowCommon.BeginStyle || 'None'}, End: ${relData.arrowCommon.EndStyle || 'None'}</p>`;
            }
            
            infoContent.innerHTML = html;
            infoPanel.style.display = 'block';
        }

        function showTableInfo(uuid, table) {
            const infoPanel = document.getElementById('info-panel');
            const infoContent = document.getElementById('info-content');
            
            let html = `<h4>${table.name}</h4>`;
            html += `<p><strong>Total fields:</strong> ${table.fields.length}</p>`;
            
            if (table.fields && table.fields.length > 0) {
                html += '<table style="width: 100%; border-collapse: collapse; margin-top: 10px;">';
                html += '<tr>';
                html += '<th style="border: 1px solid #ddd; padding: 8px; background: #f8f9fa;">Field</th>';
                html += '<th style="border: 1px solid #ddd; padding: 8px; background: #f8f9fa;">Type</th>';
                html += '<th style="border: 1px solid #ddd; padding: 8px; background: #f8f9fa;">Nullable</th>';
                html += '<th style="border: 1px solid #ddd; padding: 8px; background: #f8f9fa;">Comment</th>';
                html += '</tr>';
                
                table.fields.forEach(field => {
                    html += `<tr>`;
                    html += `<td style="border: 1px solid #ddd; padding: 8px;">${field.Name}</td>`;
                    html += `<td style="border: 1px solid #ddd; padding: 8px;">${field.Type}${field.Length > 0 ? `(${field.Length})` : ''}</td>`;
                    html += `<td style="border: 1px solid #ddd; padding: 8px;">${field.IsNullable ? 'Yes' : 'No'}</td>`;
                    html += `<td style="border: 1px solid #ddd; padding: 8px;">${field.Comment || ''}</td>`;
                    html += `</tr>`;
                });
                
                html += '</table>';
            } else {
                html += '<p>No field information available for this table.</p>';
            }
            
            infoContent.innerHTML = html;
            infoPanel.style.display = 'block';
        }

        function updateDebugInfo() {
            const debugDiv = document.getElementById('debug-info');
            let html = '<strong>Debug Information:</strong><br>';
            html += `Total Objects: ${Object.keys(modelData.ObjectJsons).length}<br>`;
            html += `Tables Found: ${Object.keys(tablesMap).length}<br>`;
            html += `Display Objects: ${Object.keys(displayObjectsMap).length}<br>`;
            
            if (diagramInfo.paperSize && diagramInfo.pagesSize) {
                html += `<br><strong>Canvas Info:</strong><br>`;
                html += `Paper Size: ${diagramInfo.paperSize.Width} × ${diagramInfo.paperSize.Height}<br>`;
                html += `Pages: ${diagramInfo.pagesSize.Width} × ${diagramInfo.pagesSize.Height}<br>`;
                html += `Total Size: ${diagramInfo.paperSize.Width * diagramInfo.pagesSize.Width} × ${diagramInfo.paperSize.Height * diagramInfo.pagesSize.Height}<br>`;
            }
            
            debugDiv.innerHTML = html;
        }

        function toggleDebug() {
            const debugDiv = document.getElementById('debug-info');
            const button = document.getElementById('show-debug');
            if (debugDiv.style.display === 'none' || !debugDiv.style.display) {
                debugDiv.style.display = 'block';
                button.textContent = 'Hide Debug Info';
            } else {
                debugDiv.style.display = 'none';
                button.textContent = 'Show Debug Info';
            }
        }

        function zoom(factor) {
            currentZoom *= factor;
            currentZoom = Math.max(0.1, Math.min(5, currentZoom)); // Limit zoom range
            const zoomGroup = document.getElementById('zoom-group');
            zoomGroup.setAttribute('transform', `scale(${currentZoom})`);
        }

        function resetZoom() {
            currentZoom = 1;
            const zoomGroup = document.getElementById('zoom-group');
            zoomGroup.setAttribute('transform', 'scale(1)');
        }

        function startDrag(e) {
            if (e.target.tagName === 'text') return; // Don't drag when clicking text
            
            draggedElement = e.currentTarget;
            const transform = draggedElement.getAttribute('transform');
            const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
            const x = parseFloat(match[1]);
            const y = parseFloat(match[2]);
            
            const svg = document.getElementById('diagram');
            const pt = svg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
            
            dragOffset.x = (svgP.x / currentZoom) - x;
            dragOffset.y = (svgP.y / currentZoom) - y;
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
            e.preventDefault();
            e.stopPropagation();
        }

        function drag(e) {
            if (!draggedElement) return;
            
            const svg = document.getElementById('diagram');
            const pt = svg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
            
            const x = (svgP.x / currentZoom) - dragOffset.x;
            const y = (svgP.y / currentZoom) - dragOffset.y;
            
            draggedElement.setAttribute('transform', `translate(${x}, ${y})`);
            
            // Update connected relationships
            const tableUUID = draggedElement.getAttribute('data-uuid');
            updateConnectedRelationships(tableUUID, x, y);
        }

        function updateConnectedRelationships(tableUUID, x, y) {
            // Get all relationships connected to this table
            const connectedRelationships = tableRelationships[tableUUID] || [];
            
            connectedRelationships.forEach(relUUID => {
                const relData = relationshipsMap[relUUID];
                if (!relData) return;
                
                // Find the relationship SVG element
                const relGroup = document.querySelector(`g[data-uuid="${relUUID}"]`);
                if (!relGroup) return;
                
                // Get the path element
                const path = relGroup.querySelector('path.relationship-line');
                const clickPath = relGroup.querySelector('path[stroke="transparent"]');
                if (!path) return;
                
                // Recalculate the path based on current table positions
                const newPath = recalculateRelationshipPath(relUUID, relData);
                if (newPath) {
                    path.setAttribute('d', newPath);
                    if (clickPath) {
                        clickPath.setAttribute('d', newPath);
                    }
                }
            });
        }
        
        function recalculateRelationshipPath(relUUID, relData) {
            if (!relData.data.vertices || relData.data.vertices.length < 2) return null;
            
            // Get the connected tables' current positions
            const connectInfos = relData.data.connectInfos || [];
            if (connectInfos.length < 2) return null;
            
            // Get current positions of connected tables
            const table1UUID = connectInfos[0].RefUUID;
            const table2UUID = connectInfos[1].RefUUID;
            
            const table1Element = document.querySelector(`g[data-uuid="${table1UUID}"]`);
            const table2Element = document.querySelector(`g[data-uuid="${table2UUID}"]`);
            
            if (!table1Element || !table2Element) return null;
            
            // Extract current positions from transform
            const getPosition = (element) => {
                const transform = element.getAttribute('transform');
                const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                if (!match) return { x: 0, y: 0 };
                return {
                    x: parseFloat(match[1]),
                    y: parseFloat(match[2])
                };
            };
            
            const pos1 = getPosition(table1Element);
            const pos2 = getPosition(table2Element);
            
            // Get table dimensions from the layout info
            const layout1 = layoutInfo[table1UUID];
            const layout2 = layoutInfo[table2UUID];
            
            if (!layout1 || !layout2) return null;
            
            // Calculate the center points of the tables
            const center1 = {
                x: pos1.x + layout1.rect.Width / 2,
                y: pos1.y + layout1.rect.Height / 2
            };
            
            const center2 = {
                x: pos2.x + layout2.rect.Width / 2,
                y: pos2.y + layout2.rect.Height / 2
            };
            
            // For now, create a simple line between table centers
            // In a more sophisticated implementation, we would use the connection indices
            // to determine which edge of each table to connect to
            const vertices = relData.data.vertices;
            
            // Calculate the bounding box of the original relationship
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            vertices.forEach(v => {
                minX = Math.min(minX, v.X);
                minY = Math.min(minY, v.Y);
                maxX = Math.max(maxX, v.X);
                maxY = Math.max(maxY, v.Y);
            });
            
            const origWidth = maxX - minX;
            const origHeight = maxY - minY;
            
            // Calculate new bounding box based on table positions
            const newMinX = Math.min(center1.x, center2.x) - 50;
            const newMinY = Math.min(center1.y, center2.y) - 50;
            const newMaxX = Math.max(center1.x, center2.x) + 50;
            const newMaxY = Math.max(center1.y, center2.y) + 50;
            
            const newWidth = newMaxX - newMinX;
            const newHeight = newMaxY - newMinY;
            
            // Scale and translate the vertices
            const scaleX = origWidth > 0 ? newWidth / origWidth : 1;
            const scaleY = origHeight > 0 ? newHeight / origHeight : 1;
            
            // Build the new path
            let d = '';
            
            // Check if this is an elbow connector
            if (relData.data.connectorCommon && relData.data.connectorCommon.Type === 'Elbow') {
                // Transform vertices and generate elbow path
                const transformedVertices = vertices.map(v => {
                    // Normalize vertex position (0-1 range)
                    const normX = origWidth > 0 ? (v.X - minX) / origWidth : 0.5;
                    const normY = origHeight > 0 ? (v.Y - minY) / origHeight : 0.5;
                    
                    // Apply to new bounding box
                    return {
                        X: normX * newWidth,
                        Y: normY * newHeight
                    };
                });
                
                d = generateElbowPath(transformedVertices, newMinX, newMinY, 
                                    relData.data.connectorCommon.StartAxis || 'Horizontal');
            } else {
                // Default to straight lines
                vertices.forEach((v, i) => {
                    // Normalize vertex position (0-1 range)
                    const normX = origWidth > 0 ? (v.X - minX) / origWidth : 0.5;
                    const normY = origHeight > 0 ? (v.Y - minY) / origHeight : 0.5;
                    
                    // Apply to new bounding box
                    const newX = newMinX + normX * newWidth;
                    const newY = newMinY + normY * newHeight;
                    
                    if (i === 0) {
                        d = `M ${newX} ${newY}`;
                    } else {
                        d += ` L ${newX} ${newY}`;
                    }
                });
            }
            
            return d;
        }

        function endDrag() {
            draggedElement = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', endDrag);
        }

        function exportSVG() {
            const svg = document.getElementById('diagram');
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            downloadFile(blob, 'diagram.svg');
        }

        function exportPNG() {
            const svg = document.getElementById('diagram');
            const svgData = new XMLSerializer().serializeToString(svg);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            img.onload = function() {
                canvas.width = svg.getAttribute('width');
                canvas.height = svg.getAttribute('height');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                canvas.toBlob(blob => {
                    downloadFile(blob, 'diagram.png');
                });
            };
            
            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
        }

        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>